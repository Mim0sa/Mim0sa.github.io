---
title: 事件传递及响应链
tags: ["iOS", "笔记"]
---

试想一下假如你是一台手机📟，当有人触摸了屏幕之后，你需要找到他具体触摸了什么东西，他可能触摸是一个按钮，或一个列表，也有可能是一个一不小心的误触，你会设计一个怎么样的机制和系统来处理呢？假如有两个按钮重叠了，或者遇到在滚动列表上需要拖动某个按钮的情况，你设计的机制能正常的运作嘛？在 iOS 中系统通过 UIKit 已经为我们设计好了一套方案，也就是本文浅谈的内容： iOS 中的事件传递及响应链机制。

![Responder Chain](/resources/Responder Chain.png)

<!--more-->

## 谁来响应事件

在 UIKit 中我们使用响应者对象（*Responder*）接收和处理事件。一个响应者对象一般是 `UIResponder` 类的实例，它常见的子类包括 `UIView`，`UIViewController` 和 `UIApplication`，这意味着几乎所有我们日常使用的控件都是响应者，如 `UIButton`，`UILabel` 等等。

![Responders](/resources/Responders.png)

在 `UIResponder` 及其子类中，我们是通过有关触摸（*UITouch*）的方法来处理和传递事件（*UIEvent*），具体的方法如下：

```swift
open func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?)
```

>  `UIResponder` 还可以处理 `UIPress`、加速计、远程控制事件，这里仅讨论触摸事件。

在 `UITouch` 内，存储了大量触摸相关的数据，当手指在屏幕上移动时，所对应的 `UITouch` 数据也会更新，例如：这个触摸是在哪个 window 或者哪个 view 内发生的？当前触摸点的坐标是？前一个触摸点的坐标是？当前触摸事件的状态是？这些都存储在 `UITouch` 里面。另外需要注意的是，在这四个方法的参数中，传递的是 `UITouch` 类型的一个集合（而不是一个 `UITouch`），这对应了两根及以上手指触摸同一个视图的情况。

## 确定第一响应者

当有人用触摸了屏幕之后，我们需要找到使用者到底触摸了一个什么东西，或者可以理解为我们要找到，在这次使用者触摸之后，使用者最想要哪个控件发起响应。这个过程就是确定这次触摸事件的第一响应者是谁。

在触摸发生后，`UIApplication` 会触发 `open func sendEvent(_ event: UIEvent)` 将一个封装好的 `UIEvent` 传给 `UIWindow`，也就是当前展示的 `UIWindow`，通常情况接下来会传给当前展示的 `UIViewController`，接下来传给 `UIViewController` 的根视图。这个过程是一条龙服务，没有分叉。但是在传递给当前 `UIViewController` 的根视图之后，就是开发人员的主战场，视图的层级结构就可以变得错综复杂起来了。

> 这里我们使用 `UIView` 来作为视图层级的主要组成元素，便于理解。但不止 `UIView` 可以响应事件，实际只要是 `UIResponder` 的子类，都可以响应和传递事件。后文会大量用 `视图` 或 `UIView` 来举例，实则代指一切合格的响应者。

![UIApplication to rootView](/resources/UIApplication to rootView.png)

回到开头的问题，我现在变成了一台手机📱，并且我知道有人触摸了屏幕。我所有的信息是触摸点的坐标，我无法直接知道用户是想点哪个视图，但我知道应该就是视图层级中其中的某一个。我需要一个策略来找到第一响应者，UIKit 为我们提供了命中测试（*hit-testing*）来确定触摸事件的响应者，这个策略具体是：

![Hit-testing](/resources/Hit-testing.png)

关于图中还有一些细节需要说明

* 在 `检查自身可否接收事件` 中，如果视图符合以下三个条件中的任一个，都会无法接收事件：
  1. `view.isUserInteractionEnabled = false` 
  2. `view.alpha < 0.01` 
  3. `view.isHidden = true` 
* `检查坐标是否在自身内部` 这个过程使用了 `func point(inside point: CGPoint, with event: UIEvent?) -> Bool` 方法来判断坐标是否在自身内部，该方法是可以被重写的。
* `从后往前遍历子视图重复执行` 指的是按照 `FILO` 的原则，将其所有子视图按照「后添加的先遍历」的规则进行命中测试。该规则保证了系统会优先测试视图层级树中最后添加的视图，如果视图之间有重叠，该视图也是同级视图中展示最完整的视图，即用户最可能想要点的那个视图。

下面我们举个例子，下图中灰色视图 A 可以看作是当前 `UIViewController` 的根视图，右侧表示了各个视图的层级结构。⚠️并且注意，D 比 B 更晚添加到 A 上。

![Find the first responder](/resources/Find the first responder.png)


## 通过响应者链传递事件

## 手势的优先级