---
title: 事件传递及响应链
tags: ["iOS", "笔记"]
---

试想一下假如你是一台手机📟，当有人触摸了屏幕之后，你需要找到他具体触摸了什么东西，他可能触摸是一个按钮，或一个列表，也有可能是一个一不小心的误触，你会设计一个怎么样的机制和系统来处理呢？假如有两个按钮重叠了，或者遇到在滚动列表上需要拖动某个按钮的情况，你设计的机制能正常的运作嘛？在 iOS 中系统通过 UIKit 已经为我们设计好了一套方案，也就是本文浅谈的内容： iOS 中的事件传递及响应链机制。

![Responder Chain](/resources/Responder Chain.png)

<!--more-->

## 谁来响应事件

在 UIKit 中我们使用响应者对象（*Responder*）接收和处理事件。一个响应者对象一般是 `UIResponder` 类的实例，它常见的子类包括 `UIView`，`UIViewController` 和 `UIApplication`，这意味着几乎所有我们日常使用的控件都是响应者，如 `UIButton`，`UILabel` 等等。

![Responders](/resources/Responders.png)

在 `UIResponder` 及其子类中，我们是通过有关触摸（*UITouch*）的方法来处理和传递事件（*UIEvent*），具体的方法如下：

```swift
open func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?)
```

>  `UIResponder` 还可以处理 `UIPress`、加速计、远程控制事件，这里仅讨论触摸事件。

在 `UITouch` 内，存储了大量触摸相关的数据，当手指在屏幕上移动时，所对应的 `UITouch` 数据也会更新，例如：这个触摸是在哪个 window 或者哪个 view 内发生的？当前触摸点的坐标是？前一个触摸点的坐标是？当前触摸事件的状态是？这些都存储在 `UITouch` 里面。另外需要注意的是，在这四个方法的参数中，传递的是 `UITouch` 类型的一个集合（而不是一个 `UITouch`），这对应了两根及以上手指触摸同一个视图的情况。

## 确定第一响应者

回到开始的问题，假如你是一台手机📱，在有人用触摸了屏幕之后，我们需要找到使用者到底触摸了一个什么东西，或者可以理解为我们要找到，在这次使用者触摸之后，使用者最想要哪个控件发起响应。这个过程就是确定这次触摸事件的第一响应者是谁。

在触摸发生后，`UIApplication` 会触发 `open func sendEvent(_ event: UIEvent)` 将一个封装好的 `UIEvent` 传给 `UIWindow`，也就是当前展示的 `UIWindow`，通常情况接下来会传给当前展示的 `UIViewController`，接下来传给 `UIViewController` 的根视图。这个过程是一条龙服务，没有分叉。但是在传递给当前 `UIViewController` 的根视图之后，视图的层级结构就可以变得复杂起来了。

![UIApplication to rootView](/resources/UIApplication to rootView.png)

好我现在变成了一台手机📱，我知道有人触摸了屏幕，假设我也知道触摸的点的坐标，但我无法直接知道用户是想点 A B C D E 中的哪个视图，但我知道应该就是其中的某一个（不然就是一个需要被丢弃的事件）。我需要一个策略来找到第一响应者，UIKit 为我们提供了命中测试（*hit-testing*）来确定触摸事件的响应者，这个策略具体是：

![Hit-testing](/resources/Hit-testing.png)

下面我们举个例子，下图中灰色视图 A 可以看作是当前 `UIViewController` 的根视图，右侧表示了各个视图的层级结构。⚠️并且注意，我们可以看到，D 比 B 晚添加到 A 上。

![Find the first responder](/resources/Find the first responder.png)


## 通过响应者链传递事件

## 手势的优先级