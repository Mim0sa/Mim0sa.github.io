---
title: 响应链及手势识别
tags: ["iOS", "笔记"]
key: blog-2020-11-16
---

在上一篇「[事件传递及响应链](https://mim0sa.github.io/2020/11/05/事件传递及响应链.html)」中介绍了当屏幕上发生一次触摸之后，系统会如何寻找「第一响应者」，在寻找到「第一响应者」之后，如何确定「响应链」以及如何沿「响应链」传递事件。在上一篇文章的环境中，是不使用 `UIGestureRecognizer` 的。但是在我们平时的开发中想要给一个 `UIView` 加上处理事件的能力的话，使用 `UIGestureRecognizer` 及其子类比继承一个 `UIView` 的类、重写 touches 方法要方便的很多。这两种方法对事件的处理机制相互影响又有所不同。这也是本文的讨论内容：通过响应链及手势识别处理事件。

![Responder Chain Z](/resources/Responder & Gesture.png)

<!--more-->

首先我们先回顾一下事件传递及响应链的大致流程：

1. 通过「命中测试」来找到「第一响应者」
2. 由「第一响应者」来确定「响应链」
3. 将事件沿「响应链」传递
4. 事件被某个响应者接收，或没有响应者接收从而被丢弃

在步骤 3 中，事件沿「响应链」传递这个过程，就是响应者通过调用其 `next` 的 touches 系列方法来实现的。在上篇文章中我们也提到，假如我们使用 `UIControl` 等类作为响应者，这些类本身就不会调用其 `next` 的 touches 系列方法，从而实现阻断响应链的效果，也可以认为是实现接受某个事件的效果。那在这篇文章中，我们将浅析在有  `UIGestureRecognizer` 参与的情况下，事件的处理和接收是如何运作的。



## 当手势识别参与响应链

上篇文章中，我们只讨论了下图中蓝色部分事件沿响应链传递的流程，但实际上，同时一起发生的还有图中下半部分手势识别的部分。

![Responder x Gesture](/resources/Responder x Gesture.png)

从图中我们可以看到，在通过命中测试找到第一响应者之后，会将 `UITouch` 分发给 `UIResponder` 的 touches 系列方法（具体方法见上篇文章），同时也会分发给手势识别系统，让这两个处理系统同时工作。

首先要注意的是，上图中蓝色部分的流程并不会只执行一次，举例来说：当我们用一根手指在一个视图上缓慢滑动时，会产生一个 `UITouch` 对象，这个 `UITouch` 对象会随着你手指的滑动，不断的更新自身，同时也不断地触发 touches 系列方法。一般来说，我们会得到如下类似的触发顺序：

```
touchesBegan     // 手指触摸屏幕
touchesMoved     // 手指在屏幕上移动
touchesMoved     // ...
...
touchesMoved     // ...
touchesMoved     // 手指在屏幕上移动
touchesEnded     // 手指离开屏幕
```

`UITouch` 的 `gestureRecognizers` 属性中的存储了在寻找第一响应者的过程中收集到的手势，而在不断触发 touches 系列方法的过程中，手势识别系统也在在不停的判断当前这个 `UITouch` 是否符合收集到的某个手势。

**当手势识别成功：**被触摸的那个视图，也就是第一响应者会收到 touchesCancelled 的消息，并且该视图不会再收到来自该 `UITouch` 的 touches 事件。同时也让该 `UITouch` 关联的其他手势也收到 touchesCancelled，并且之后不再收到此 `UITouch` 的 touches 事件。这样做就实现了该识别到的手势能够独占该 `UITouch`。具体表现参考如下：

```
touchesBegan     // 手指触摸屏幕
touchesMoved     // 手指在屏幕上移动
touchesMoved     // ...
...
touchesMoved     // ...
touchesMoved     // 手指在屏幕上移动
touchesCancelled // 手势识别成功，touches 系列方法被阻断
// 现在手指💅并没有离开屏幕
// 但如果继续滑动🛹的话
// 并不会触发 touches 系列方法
```

**当手势识别未成功：**指暂时未识别出来，不代表以后不会识别成功，不会阻断响应链。注意这里指的是未成功，并不一定是失败。在手势的内部状态中，手势大部分情况下状态是 `.possible`，指的是 `UITouch` 暂时与其不匹配，但之后可能有机会识别成功。而 `.fail` 是真的识别失败，指的是以目前的触摸情况来看已经不可能是这个手势了，并且在下个 runloop 会从 `gestureRecognizers` 中移除该手势。



## 举个例子🌰

下面举个简单的例子模拟一下响应链和手势的相互影响。现在用一根手指，在一个视图上触摸并滑动一段距离。下图给出了视图不带手势的情况，和带一个 `UIPanGestureRecognizer` 手势的情况。

![Drag with one finger](/resources/Drag with one finger.png)

从图中我们可以看到，当不带手势的情况下，手指按下去的时候，响应者的 `touchBegan` 方法会触发，随着手指的移动，`touchMoved` 会不断触发，当手指结束移动并抬起来的时候，`touchEnded` 会触发。在这个过程中，我们接收到一直是一个不断更新的 `UITouch`。

在该视图有添加一个 `UIPanGestureRecognizer` 手势的情况下，我们多了下方这一条来表示与响应链同时工作的手势识别系统，可以看到手势识别系统也是在手指按下去那一刻就开始工作的，前半段处于一直正在识别的状态。在我们拖动了很小一段距离之后（注意这时候我们的手指还没抬起）， 手势识别系统确定了该 `UITouch` 所做的动作是符合 `UIPanGestureRecognizer` 的特点的，于是给该视图的响应链发送了 `touchCancelled` 的信息，从而阻止这个 `UITouch` 继续触发这个视图的 touches 系列方法（同时也取消了别的相关手势的 touches 系列方法，图中未体现）。在这之后，被调用的只有与手势关联的 target-action 方法（也就是图中的墨绿色节点 `call PanFunction`）。

##### 再进一步理解

为了图片的美观和易读，在图片中我隐去了不少细节，在此列出：

1. 手势识别器的状态在图中未标出：
   * 手势在图中 `recognizing` 的橙色节点处和 `recognized` 棕色节点处都处于 `.possible` 状态
   * 手势在图中绿色节点处的状态变化是 `.began` -> `[.changed]` -> `ended`
2. 手势识别器不是响应者，但也有 touches 系列方法，比它所添加的视图的 touches 方法更早那么一点触发
   * 从图中也可以看出，手势那条线上的每个节点都稍靠左一些
   * 手势那条线上的橙、棕、墨绿色节点处也可以看做手势识别器的 touches 方法触发
3. 更详细的触发顺序应当如下图所示

![Drag with one finger with more](/resources/Drag with one finger with more.png)

> 手势和响应者的 touches 方法名字是一样的，都是「began」，「moved」，「ended」，「cancelled」。很容易和手势识别器的 `state` 属性搞混，`state` 属性是根据每个手势的类型（离散型/连续型）的不同，可能有 `.possible`、`.began`、`.changed`、`.ended`、`.cancelled`、`.failed` 这些状态，名字很像方法名很像但不是一回事。



## UIControl 与手势识别